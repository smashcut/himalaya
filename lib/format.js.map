{"version":3,"sources":["format.js"],"names":["splitHead","unquote","format","formatAttributes","str","sep","idx","indexOf","slice","length","car","charAt","end","isQuoteStart","nodes","options","map","node","type","outputNode","tagName","toLowerCase","attributes","children","content","includePositions","position","reduce","acc","curr","parts","trim","key","value"],"mappings":";;;;;QAAgBA,S,GAAAA,S;QAMAC,O,GAAAA,O;QAUAC,M,GAAAA,M;QAmBAC,gB,GAAAA,gB;AAnCT,SAASH,SAAT,CAAoBI,GAApB,EAAyBC,GAAzB,EAA8B;AACnC,MAAMC,MAAMF,IAAIG,OAAJ,CAAYF,GAAZ,CAAZ;AACA,MAAIC,QAAQ,CAAC,CAAb,EAAgB,OAAO,CAACF,GAAD,CAAP;AAChB,SAAO,CAACA,IAAII,KAAJ,CAAU,CAAV,EAAaF,GAAb,CAAD,EAAoBF,IAAII,KAAJ,CAAUF,MAAMD,IAAII,MAApB,CAApB,CAAP;AACD;;AAEM,SAASR,OAAT,CAAkBG,GAAlB,EAAuB;AAC5B,MAAMM,MAAMN,IAAIO,MAAJ,CAAW,CAAX,CAAZ;AACA,MAAMC,MAAMR,IAAIK,MAAJ,GAAa,CAAzB;AACA,MAAMI,eAAeH,QAAQ,GAAR,IAAeA,QAAQ,GAA5C;AACA,MAAIG,gBAAgBH,QAAQN,IAAIO,MAAJ,CAAWC,GAAX,CAA5B,EAA6C;AAC3C,WAAOR,IAAII,KAAJ,CAAU,CAAV,EAAaI,GAAb,CAAP;AACD;AACD,SAAOR,GAAP;AACD;;AAEM,SAASF,MAAT,CAAiBY,KAAjB,EAAwBC,OAAxB,EAAiC;AACtC,SAAOD,MAAME,GAAN,CAAU,UAACC,IAAD,EAAU;AACzB,QAAMC,OAAOD,KAAKC,IAAlB;AACA,QAAMC,aACJD,SAAS,SAAT,GACI;AACAA,gBADA;AAEAE,eAASH,KAAKG,OAAL,CAAaC,WAAb,EAFT;AAGAC,kBAAYnB,iBAAiBc,KAAKK,UAAtB,CAHZ;AAIAC,gBAAUrB,OAAOe,KAAKM,QAAZ,EAAsBR,OAAtB;AAJV,KADJ,GAOI,EAAEG,UAAF,EAAQM,SAASP,KAAKO,OAAtB,EARN;AASA,QAAIT,QAAQU,gBAAZ,EAA8B;AAC5BN,iBAAWO,QAAX,GAAsBT,KAAKS,QAA3B;AACD;AACD,WAAOP,UAAP;AACD,GAfM,CAAP;AAgBD;;AAEM,SAAShB,gBAAT,CAA2BmB,UAA3B,EAAuC;AAC5C,SAAOA,WAAWK,MAAX,CAAkB,UAACC,GAAD,EAAMC,IAAN,EAAe;AACtC,QAAMC,QAAQ9B,UAAU6B,KAAKE,IAAL,EAAV,EAAuB,GAAvB,CAAd;AACA,QAAMC,MAAMF,MAAM,CAAN,CAAZ;AACA,QAAMG,QAAQ,OAAOH,MAAM,CAAN,CAAP,KAAoB,QAApB,GAA+B7B,QAAQ6B,MAAM,CAAN,CAAR,CAA/B,GAAmD,IAAjE;AACA,QAAI,CAACG,KAAL,EAAY;AACVL,UAAII,GAAJ,IAAW,IAAX;AACD,KAFD,MAEO;AACLJ,UAAII,GAAJ,IAAWC,KAAX;AACD;AACD,WAAOL,GAAP;AACD,GAVM,EAUJ,EAVI,CAAP;AAWD","file":"format.js","sourcesContent":["export function splitHead (str, sep) {\n  const idx = str.indexOf(sep)\n  if (idx === -1) return [str]\n  return [str.slice(0, idx), str.slice(idx + sep.length)]\n}\n\nexport function unquote (str) {\n  const car = str.charAt(0)\n  const end = str.length - 1\n  const isQuoteStart = car === '\"' || car === \"'\"\n  if (isQuoteStart && car === str.charAt(end)) {\n    return str.slice(1, end)\n  }\n  return str\n}\n\nexport function format (nodes, options) {\n  return nodes.map((node) => {\n    const type = node.type\n    const outputNode =\n      type === 'element'\n        ? {\n          type,\n          tagName: node.tagName.toLowerCase(),\n          attributes: formatAttributes(node.attributes),\n          children: format(node.children, options)\n        }\n        : { type, content: node.content }\n    if (options.includePositions) {\n      outputNode.position = node.position\n    }\n    return outputNode\n  })\n}\n\nexport function formatAttributes (attributes) {\n  return attributes.reduce((acc, curr) => {\n    const parts = splitHead(curr.trim(), '=')\n    const key = parts[0]\n    const value = typeof parts[1] === 'string' ? unquote(parts[1]) : null\n    if (!value) {\n      acc[key] = true\n    } else {\n      acc[key] = value\n    }\n    return acc\n  }, {})\n}\n"]}